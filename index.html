<!DOCTYPE html>
<html lang="he">
<head>
  <meta charset="UTF-8">
  <title>תופסת 3D - דמויות חדשות</title>
  <style>
    body { margin: 0; overflow: hidden; background: #e5ecff;}
    #overlay {
      position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.95); border-radius: 18px; padding: 12px 22px;
      font-size: 20px; font-family: 'Varela Round', Arial, sans-serif;
      z-index: 9; box-shadow: 0 2px 12px #9ac0fc6e; color: #1a2751;
    }
    #timer {
      position: absolute; top: 15px; right: 32px; font-size: 26px;
      background: #fff; padding: 7px 24px; border-radius: 18px; box-shadow: 0 2px 9px #b2c5ef49;
      color: #175f18; font-weight: bold; font-family: monospace;
      z-index: 11; letter-spacing: 2px;
    }
    #gameover, #victory {
      display: none; position: absolute; left: 50%; top: 35%; transform: translate(-50%, -50%);
      background: #fff; border-radius: 22px; box-shadow: 0 2px 22px #a2c0fc99;
      padding: 36px 40px; font-size: 2rem; font-weight: bold; z-index: 99; text-align: center;
    }
    #gameover { color: #ea1a1a; }
    #victory { color: #269c35; }
    #restart, #restart2 {
      margin-top: 18px; background: #53b54a; color: #fff; font-size: 1.2rem;
      padding: 10px 36px; border: none; border-radius: 12px; cursor: pointer;
      box-shadow: 0 2px 10px #61ff5e26;
    }
    #restart:hover, #restart2:hover { background: #367933; }
  </style>
</head>
<body>
  <audio id="lose-audio" src="loseSong.mp3" preload="auto"></audio>
  <div id="overlay">תברחחחחח</div>
  <div id="timer">00:20</div>
  <div id="gameover">אחחח את פלי<br><button id="restart">נסה שוב</button></div>
  <div id="victory">ניצחת!<br><button id="restart2">שחק שוב</button></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
  <script>
    // טקסט גדול מעל הדמות
    function makeTextLabel(text, color="#2796ff") {
      const canvas = document.createElement('canvas');
      canvas.width = 600;
      canvas.height = 150;
      const ctx = canvas.getContext('2d');
      ctx.font = "bold 70px Varela Round, Arial, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 14;
      ctx.strokeText(text, canvas.width/2, canvas.height/2);
      ctx.fillStyle = color;
      ctx.fillText(text, canvas.width/2, canvas.height/2);
      const texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(5, 1.2, 1);
      return sprite;
    }

    // דמות בלוק עם טקסטורה
    function createBlockCharacter(imgUrl, blockColor, scene, yOffset = 0) {
      return new Promise((resolve) => {
        new THREE.TextureLoader().load(imgUrl, (tex) => {
          const group = new THREE.Group();

            const materials = [
            new THREE.MeshStandardMaterial({color: blockColor}), // Right
            new THREE.MeshStandardMaterial({color: blockColor}), // Left
            new THREE.MeshStandardMaterial({color: blockColor}), // Top
            new THREE.MeshStandardMaterial({color: blockColor}), // Bottom
            new THREE.MeshStandardMaterial({map: tex}),          // Front (index 4)
            new THREE.MeshStandardMaterial({map: tex}),          // Back  (index 5)
        ];
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 1.6, 0.45),
            materials
        );
        box.position.set(0, 0.8 + yOffset, 0);
        group.add(box);

          // יד שמאל
          const leftArm = new THREE.Mesh(
            new THREE.CylinderGeometry(0.11, 0.13, 0.57, 16),
            new THREE.MeshStandardMaterial({color:0xc8ae80})
          );
          leftArm.position.set(-0.55, 1.23 + yOffset, 0.1);
          leftArm.rotation.z = Math.PI/6;
          group.add(leftArm);

          // יד ימין
          const rightArm = leftArm.clone();
          rightArm.position.x = 0.55;
          rightArm.rotation.z *= -1;
          group.add(rightArm);

          // רגל שמאל
          const leftLeg = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.14, 0.44, 12),
            new THREE.MeshStandardMaterial({color:0x303d3c})
          );
          leftLeg.position.set(-0.22, 0.22 + yOffset, 0.08);
          group.add(leftLeg);

          // רגל ימין
          const rightLeg = leftLeg.clone();
          rightLeg.position.x = 0.22;
          group.add(rightLeg);

          // בסיס
          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(0.47,0.47,0.05,24),
            new THREE.MeshStandardMaterial({color: blockColor==0x35534a ? 0x85d39e : 0xd67b7b})
          );
          base.position.set(0, yOffset, 0);
          group.add(base);

          resolve(group);
        });
      });
    }

    // === הגדרות בסיס ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xe5ecff);

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 27, 26);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(10, 20, 20);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    // קרקע
    const groundSize = 32;
    const margin = 2.5;
    const ground = new THREE.Mesh(
      new THREE.BoxGeometry(groundSize, 1, groundSize),
      new THREE.MeshStandardMaterial({color: 0xb1cfff, roughness: 0.8})
    );
    ground.position.y = -0.5;
    scene.add(ground);

    function computeBox(mesh) {
      if (!mesh.geometry.boundingBox) mesh.geometry.computeBoundingBox();
    }

    // מכשולים
    let obstacles = [];
    const obstacleMaterial = new THREE.MeshStandardMaterial({color: 0x42536e, roughness: 0.55});
    const obstacleSize = 2;

    function clearObstacles() {
      for(const o of obstacles) scene.remove(o);
      obstacles = [];
    }

    function placeObstacles() {
      clearObstacles();
      for (let i=0; i<9; ++i) {
        let safe = false, tries=0;
        let x, z;
        while(!safe && tries < 70) {
          x = Math.round(
              (Math.random()*(groundSize-2*margin-obstacleSize) + margin + obstacleSize/2 - groundSize/2)/2
          )*2;
          z = Math.round(
              (Math.random()*(groundSize-2*margin-obstacleSize) + margin + obstacleSize/2 - groundSize/2)/2
          )*2;
          safe =
            (Math.abs(x) > 3 || Math.abs(z) > 3) &&
            obstacles.every(o=>
              Math.hypot(o.position.x-x, o.position.z-z) > obstacleSize+1
            );
          tries++;
        }
        if (safe) {
          const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(obstacleSize, obstacleSize, obstacleSize),
            obstacleMaterial
          );
          mesh.position.set(x, obstacleSize/2, z);
          computeBox(mesh);
          scene.add(mesh);
          obstacles.push(mesh);
        }
      }
    }

    // קירות
    const walls = [];
    function createWalls() {
      [ [0, groundSize/2-1], [0, -groundSize/2+1], [-groundSize/2+1, 0], [groundSize/2-1, 0] ]
        .forEach(([x,z],i)=>{
          const isZ = i<2;
          const wall = new THREE.Mesh(
            new THREE.BoxGeometry(isZ ? groundSize-1 : 1, 2, isZ ? 1 : groundSize-1),
            new THREE.MeshStandardMaterial({color:0x284079})
          );
          wall.position.set(x,1,z);
          computeBox(wall);
          scene.add(wall);
          walls.push(wall);
        });
    }
    createWalls();

    function intersectBox(a, b, pad=0) {
      const abox = a.geometry.boundingBox;
      const bbox = b.geometry.boundingBox;
      return (
        Math.abs(a.position.x - b.position.x) <
          ((abox.max.x-abox.min.x)+(bbox.max.x-bbox.min.x))/2 + pad
      ) && (
        Math.abs(a.position.z - b.position.z) <
          ((abox.max.z-abox.min.z)+(bbox.max.z-bbox.min.z))/2 + pad
      );
    }

    // מיקום התחלתי פנוי באמת
    function getSafePosition(minDistFromObstacles=2.2, minDistFromOthers=3, forbidden=[]) {
      let tries = 0;
      let x, z;
      while (tries < 100) {
        x = Math.round(((Math.random()-0.5)*(groundSize-7))/2)*2;
        z = Math.round(((Math.random()-0.5)*(groundSize-7))/2)*2;
        let safe = true;
        for(const obs of obstacles) {
          if(Math.hypot(obs.position.x-x, obs.position.z-z) < obstacleSize+minDistFromObstacles)
            safe = false;
        }
        for(const pos of forbidden) {
          if(Math.hypot(pos[0]-x, pos[1]-z) < minDistFromOthers) safe = false;
        }
        if (Math.abs(x) > groundSize/2-obstacleSize-1.5 || Math.abs(z) > groundSize/2-obstacleSize-1.5) safe = false;
        if (safe) return [x,z];
        tries++;
      }
      return null;
    }

    // דמויות גלובליות
    let playerMeta = {group: null, mesh: null, label: null};
    let enemyMeta = {group: null, mesh: null, label: null};

    async function createPlayers() {
      if (playerMeta.group) scene.remove(playerMeta.group);
      if (enemyMeta.group) scene.remove(enemyMeta.group);

      let forbidden = [];
      let pxz = getSafePosition(2.5, 3, forbidden);
      if (!pxz) throw 'לא נמצא מקום פנוי לשחקן – התחלה מחדש!';
      forbidden.push(pxz);
      let exz = getSafePosition(2.5, 3, forbidden);
      if (!exz) throw 'לא נמצא מקום פנוי לאדום – התחלה מחדש!';

      // שחקן
      playerMeta.group = await createBlockCharacter("player.jpg", 0x35534a, scene);
      playerMeta.group.position.set(pxz[0], 0, pxz[1]);
      scene.add(playerMeta.group);
      playerMeta.mesh = playerMeta.group.children[0];
      computeBox(playerMeta.mesh);
      playerMeta.label = makeTextLabel("shachar", "#2796ff");
      playerMeta.label.position.set(0, 1.75, 0);
      playerMeta.group.add(playerMeta.label);

      // אויב
      enemyMeta.group = await createBlockCharacter("enemy.jpg", 0xf5f5f5, scene);
      enemyMeta.group.position.set(exz[0], 0, exz[1]);
      scene.add(enemyMeta.group);
      enemyMeta.mesh = enemyMeta.group.children[0];
      computeBox(enemyMeta.mesh);
      enemyMeta.label = makeTextLabel("TropicClient", "#e63b2e");
      enemyMeta.label.position.set(0, 1.75, 0);
      enemyMeta.group.add(enemyMeta.label);
    }

    // קלט
    let keys = {};
    document.addEventListener('keydown', e => { keys[e.code] = true; });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    // תנועת שחקן – כולל מניעת מעבר דרך מכשולים
    function move(group, mesh, dir, speed=0.23) {
      if (dir.x===0 && dir.z===0) return false;
      const step = {x: dir.x*speed, z: dir.z*speed};
      const test = mesh.clone();
      test.position.x = group.position.x + step.x;
      test.position.z = group.position.z + step.z;
      for(const wall of walls) if(intersectBox(test, wall, 0.7)) return false;
      for(const obs of obstacles) if(intersectBox(test, obs, 1.0)) return false;
      group.position.x += step.x;
      group.position.z += step.z;
      return true;
    }

    // AI – בוחר צעד שמקרב לשחקן, לא עובר דרך מכשולים
    function enemyChase() {
      const speed = 0.15;
      const dirs = [
        {x:1, z:0}, {x:-1, z:0}, {x:0, z:1}, {x:0, z:-1},
        {x:1, z:1}, {x:1, z:-1}, {x:-1, z:1}, {x:-1, z:-1}
      ];
      let minDist = Infinity, bestDir = null;
      for (const dir of dirs) {
        const test = enemyMeta.mesh.clone();
        test.position.x = enemyMeta.group.position.x + dir.x * speed;
        test.position.z = enemyMeta.group.position.z + dir.z * speed;
        let blocked = false;
        for(const wall of walls) if(intersectBox(test, wall, 0.7)) blocked = true;
        for(const obs of obstacles) if(intersectBox(test, obs, 1.0)) blocked = true;
        if(blocked) continue;
        const dist = Math.hypot(
          (test.position.x) - playerMeta.group.position.x,
          (test.position.z) - playerMeta.group.position.z
        );
        if(dist < minDist) {
          minDist = dist;
          bestDir = dir;
        }
      }
      if (bestDir) move(enemyMeta.group, enemyMeta.mesh, bestDir, speed);
    }

    // --- טיימר ובריחה ---
    let running = true, win = false, caught = false;
    let timeLeft = 20;
    let lastTick = Date.now();
    const timerDiv = document.getElementById('timer');

    function updateTimerDisplay() {
      const mm = "00";
      const ss = String(Math.max(0, Math.floor(timeLeft))).padStart(2, '0');
      timerDiv.textContent = `${mm}:${ss}`;
    }

    // --- סצנת תפיסה (השחקן משותק, האויב מזיז אותו "הלוך חזור") ---
    let hitScene = null;
    function startHitScene() {
      if (!obstacles.length) {
        document.getElementById("gameover").style.display = "block";
        running = false;
        return;
      }
      const audio = document.getElementById("lose-audio");
      if (audio) {
        audio.currentTime = 0;
        audio.play();
      }
      let minDist = Infinity, nearest = null;
      for (const obs of obstacles) {
        const d = Math.hypot(
          playerMeta.group.position.x - obs.position.x,
          playerMeta.group.position.z - obs.position.z
        );
        if (d < minDist) {
          minDist = d;
          nearest = obs;
        }
      }
      const start = {
        x: playerMeta.group.position.x,
        z: playerMeta.group.position.z
      };
      const hit = {
        x: nearest.position.x,
        z: nearest.position.z
      };
      function getAngle(from, to) {
        return Math.atan2(to.x - from.x, to.z - from.z);
      }
      const angleToHit = getAngle(start, hit);
      const angleToBack = getAngle(hit, start);

      hitScene = {
        state: 0,
        t: 0,
        count: 0,
        start, hit,
        back: {...start},
        angleToHit, angleToBack,
        prevAngle: playerMeta.group.rotation.y
      };
    }

    function lerpAngle(a, b, t) {
      let delta = b - a;
      while (delta > Math.PI) delta -= 2*Math.PI;
      while (delta < -Math.PI) delta += 2*Math.PI;
      return a + delta*t;
    }

    function animateHitScene() {
      if (!hitScene) return;
      let {state, t, start, hit, back, angleToHit, angleToBack, count} = hitScene;
      hitScene.t += 0.035;
      let newAngle;
      if (hitScene.state % 2 === 0) {
        // תנועה מהמיקום הנוכחי למכשול (השחקן פסיבי)
        playerMeta.group.position.x = start.x + (hit.x - start.x) * hitScene.t;
        playerMeta.group.position.z = start.z + (hit.z - start.z) * hitScene.t;
        enemyMeta.group.position.x = playerMeta.group.position.x;
        enemyMeta.group.position.z = playerMeta.group.position.z - 1;
        newAngle = lerpAngle(playerMeta.group.rotation.y, angleToHit, Math.min(hitScene.t*2, 1));
        playerMeta.group.rotation.y = newAngle;
        if (hitScene.t >= 1) {
          hitScene.t = 0;
          hitScene.state++;
        }
      } else {
        // תנועה חזרה (השחקן עדיין פסיבי)
        playerMeta.group.position.x = hit.x + (back.x - hit.x) * hitScene.t;
        playerMeta.group.position.z = hit.z + (back.z - hit.z) * hitScene.t;
        enemyMeta.group.position.x = playerMeta.group.position.x;
        enemyMeta.group.position.z = playerMeta.group.position.z - 1;
        newAngle = lerpAngle(playerMeta.group.rotation.y, angleToBack, Math.min(hitScene.t*2, 1));
        playerMeta.group.rotation.y = newAngle;
        if (hitScene.t >= 1) {
          hitScene.t = 0;
          hitScene.state++;
          hitScene.count++;
          if (hitScene.count >= 3) {
            hitScene = null;
            setTimeout(()=> {
              document.getElementById("gameover").style.display = "block";
            }, 300);
            running = false;
          }
        }
      }
    }

    // אתחול מחודש של המשחק
    async function restartAll() {
      let safe = false;
      let tries = 0;
      function clearGroups() {
        if (playerMeta.group) scene.remove(playerMeta.group);
        if (enemyMeta.group) scene.remove(enemyMeta.group);
      }
      clearGroups();
      while (!safe && tries < 10) {
        try {
          clearObstacles();
          placeObstacles();
          await createPlayers();
          safe = true;
        } catch(e) {
          tries++;
          clearObstacles();
        }
      }
      if (!safe && tries >= 10) location.reload();
    }

    async function resetGame() {
      running = false;
      win = false;
      caught = false;
      hitScene = null;
      timeLeft = 20;
      lastTick = Date.now();
      updateTimerDisplay();
      document.getElementById("gameover").style.display = "none";
      document.getElementById("victory").style.display = "none";
      const audio = document.getElementById("lose-audio");
      if (audio) audio.pause();
      await restartAll();
      caught = false;
      hitScene = null;
      running = true;
    }

    document.getElementById('restart').onclick = resetGame;
    document.getElementById('restart2').onclick = resetGame;

    // לולאת האנימציה
    let playersReady = false;
    restartAll().then(()=>{
      playersReady = true;
      updateTimerDisplay();
      animate();
    });

    function animate() {
      requestAnimationFrame(animate);
      if (!playersReady) return;
      if (!running && !hitScene) return;

      if (!caught && !win) {
        const now = Date.now();
        if (now - lastTick >= 1000) {
          timeLeft--;
          lastTick = now;
          updateTimerDisplay();
          if (timeLeft <= 0) {
            running = false;
            win = true;
            document.getElementById("victory").style.display = "block";
          }
        }
      }

      if (hitScene) {
        // בזמן תפיסה – השחקן לא מגיב, האויב מזיז אותו
        animateHitScene();
      } else if (running && !caught && !win) {
        // תנועה רק אם לא נתפס
        let dir = {x:0, z:0};
        if (keys['ArrowUp']||keys['KeyW']) dir.z -= 1;
        if (keys['ArrowDown']||keys['KeyS']) dir.z += 1;
        if (keys['ArrowLeft']||keys['KeyA']) dir.x -= 1;
        if (keys['ArrowRight']||keys['KeyD']) dir.x += 1;
        const len = Math.hypot(dir.x, dir.z) || 1;
        dir.x /= len; dir.z /= len;
        move(playerMeta.group, playerMeta.mesh, dir);

        enemyChase();

        const dist = Math.hypot(
          playerMeta.group.position.x - enemyMeta.group.position.x,
          playerMeta.group.position.z - enemyMeta.group.position.z
        );
        if (dist < 1.15) {
          caught = true;
          startHitScene();
        }
        playerMeta.group.rotation.y = 0; // מסובבים רק כשהולכים רגיל
      }

      camera.position.x += (playerMeta.group.position.x - camera.position.x)*0.09;
      camera.position.z += (playerMeta.group.position.z + 19 - camera.position.z)*0.08;
      camera.lookAt(playerMeta.group.position.x, 0.8, playerMeta.group.position.z);

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
